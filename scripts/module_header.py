#
# module_builder.py
#
# 20 Nov 2023
# author: Tim Spain <timothy.spain@nersc.no>

import os

from module_strings import *

# A file and generator header for each file
def write_file_header(stream, file_name):
    stream.write(
        f"""/*!
 * @file {file_name}
 *
 * Generated by {os.path.basename(__file__)}
 */
"""
        )

# Write all of the header file between the include guards
def write_header_file(header, strings):
    guard_macro = (strings[file_prefix_str]+"MODULE_"+header_suffix).upper()
    header.write(
        f"""
#ifndef {guard_macro}
#define {guard_macro}

#include "include/ConfiguredModule.hpp"
#include "include/Module.hpp"

#include "{strings[interface_prefix_str]}{strings[file_prefix_str]}.{header_suffix}"

namespace Module {{

template <> Module<{strings[class_name]}>::map Module<{strings[class_name]}>::functionMap;
class {strings[module_class_name]} : public Module<{strings[class_name]}> {{
    struct Constructor {{
        Constructor();
    }};
    static Constructor ctor;
}};

}} /* namespace Module */

#endif /* {guard_macro} */
"""
)

'''
Main program

Parse the module.cfg file in a directory and generate the corresponding
module header file.
'''
def main():
    config = get_config_with_defaults()
    
    config_status = check_config_errors(config)
    if config_status > 0:
        return config_status
    
    # Create a dictionary of common strings
    strings = common_strings(config)
    
    header = open(strings[header_file_path_str], "w", encoding=file_encoding)
    
    write_file_header(header, strings[header_file_name_str])
    write_header_file(header, strings)
    header.close()
    
if __name__ == "__main__":
    main()
