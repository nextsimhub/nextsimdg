#
# module_builder.py
#
# 15 Nov 2023
# author: Tim Spain <timothy.spain@nersc.no>

import configparser
import os

default_str = "DEFAULT"
module_file_str = "module.cfg"
module_section_str = "module"
module_file_prefix = "module"
header_suffix = "hpp"
source_suffix = "cpp"
name_str = "name"
file_prefix_str = "file_prefix"
interface_prefix_str = "interface_prefix"
description_str = "description"
has_help_str = "has_help"
is_default_str = "is_default"
file_encoding = "utf-8"
true_str = "true"

# Variable names for the dict of common strings
class_name = "class_name"
module_class_name = "module_class_name"

# A valid implementation section has an entry "file_prefix = "
def is_impl_section_valid(section):
    return (file_prefix_str in section)

# A file and generator header for each file
def write_file_header(stream, file_suffix):
    stream.write(
        f"""/*!
 * @file {module_file_prefix}.{file_suffix}
 *
 * Generated by {os.path.basename(__file__)}
 */
"""
        )

# Write all of the header file between the include guards
def write_header_file(header, strings):
    guard_macro = (strings[file_prefix_str]+"MODULE_"+header_suffix).upper()
    header.write(
        f"""
#ifndef {guard_macro}
#define {guard_macro}

#include "include/ConfiguredModule.hpp"
#include "include/Module.hpp"

#include "{strings[interface_prefix_str]}{strings[file_prefix_str]}.{header_suffix}"

namespace Module {{

template <> Module<{strings[class_name]}>::map Module<{strings[class_name]}>::functionMap;
class {strings[module_class_name]} : public Module<{strings[class_name]}> {{
    struct Constructor {{
        Constructor();
    }};
    static Constructor ctor;
}};

}} /* namespace Module */

#endif /* {guard_macro} */
"""
)

def write_source_file(source, config, strings):
    # List over all implementation sections that contain a file_prefix entry
    valid_impl_sections = []
    for section in config:
        if section in (module_section_str, default_str,):
            continue
        else:
            if file_prefix_str in config[section]:
                valid_impl_sections.append(section)
                if is_default_str in config[section] and config[section][is_default_str]:
                    default_impl = section

    module_templ = f"Module<{strings[class_name]}>"

    source.write("#include \"module.hpp\"\n")
    source.write("\n")
    for section in valid_impl_sections:
        source.write(f"#include \"{config[section][file_prefix_str]}.{header_suffix}\"\n")
    source.write("""
#include<string>

namespace Module {
""")
    impl_strings = {}
    for section in valid_impl_sections:
        impl_strings[section] = config[section][file_prefix_str].upper()
        source.write(f"const std::string {impl_strings[section]} = \"{section}\";\n")
    source.write(f"""
template <>
{module_templ}::map {module_templ}::functionMap = {{
""")
    for section in valid_impl_sections:
        source.write(f"    {{ {impl_strings[section]}, newImpl<{strings[class_name]}, {section}> }},\n")
    source.write(f"""}};

template <>
{module_templ}::fn {module_templ}::spf = functionMap.at({default_impl});
template <>
std::unique_ptr<{strings[class_name]} {module_templ}::staticInstance
    = std::move({module_templ}::spf());

template <> std::string {module_templ}::moduleName() {{ return \"{strings[class_name]}\"; }}

template <> HelpMap& getHelpRecursive<{strings[class_name]}>(HelpMap& map, bool getAll)
{{
    const std::string& pfx = Nextsim::ConfiguredModule::MODULE_PREFIX;
    map[pfx].push_back({{ pfx + "." + {module_templ}::moduleName(), ConfigType::MODULE,
        {{ """)
    for section in valid_impl_sections:
        source.write(f"{impl_strings[section]}, ")
    source.write(f"}}, {impl_strings[default_impl]}, \"\",\n")
    source.write(f"        \"{config[module_section_str][description_str]}\" }});\n")
    for section in valid_impl_sections:
        if (has_help_str in config[section]) and (config[section][has_help_str] == true_str):
            source.write(f"{section}::getHelpRecursive(map, getAll);\n")
    source.write(f"""}}
template <> {strings[class_name]}& getImplementation<{strings[class_name]}>()
{{
    return getImplTemplate<{strings[class_name]}, {strings[module_class_name]}>();
}}
template <> void setImplementation<{strings[class_name]}>(const std::string& implName)
{{
    setImplTemplate<{strings[module_class_name]}>(implName);
}}
template <> std::unique_ptr<{strings[class_name]} getInstance()
{{
    return getInstTemplate<{strings[class_name]}, {strings[module_class_name]}>();
}}

{strings[module_class_name]}::Constructor {strings[module_class_name]}::ctor;
{strings[module_class_name]}::Constructor::Constructor()
{{
    addToConfiguredModules<{strings[class_name]}, {strings[module_class_name]}>();
}}
""")
    source.write("""
} /* namespace Module */
""")
    
'''
Main program

Parse the module.cfg file in a directory and generate the corresponding
module source and header files.
'''
def main():
    config = configparser.ConfigParser()
    config.read(module_file_str)
    
    # Add in defaults, if optional data is absent
    if not interface_prefix_str in config[module_section_str]:
        config[module_section_str][interface_prefix_str] = ""
    
    if not description_str in config[module_section_str]:
        config[module_section_str][description_str] = ""
    
    # Error reporting if the module section is invalid
    if not name_str in config[module_section_str]:
        print(f"The main '{module_section_str}' section lacks a name for the module.")
        return 1
    
    if not file_prefix_str in config[module_section_str]:
        print(f"The main '{module_section_str}' section lacks a file prefix for the source files for the module.")
        return 2
    
    header = open(module_file_prefix + "." + header_suffix, "w", encoding=file_encoding)
    source = open(module_file_prefix + "." + source_suffix, "w", encoding=file_encoding)
    
    # Create a dictionary of common strings
    strings = {
        interface_prefix_str : config[module_section_str][interface_prefix_str],
        file_prefix_str : config[module_section_str][file_prefix_str],
        class_name : config[module_section_str][name_str],
        module_class_name : config[module_section_str][file_prefix_str]+"Module"
    }
    
    write_file_header(header, header_suffix)
    write_file_header(source, source_suffix)
    
    write_header_file(header, strings)
    write_source_file(source, config, strings)
    
    header.close()
    source.close()
    
if __name__ == "__main__":
    main()
