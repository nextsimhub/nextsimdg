#
# module_builder.py
#
# 15 Nov 2023
# author: Tim Spain <timothy.spain@nersc.no>

import configparser
import os

module_file_str = "module.cfg"
module_section_str = "module"
module_file_prefix = "module"
header_suffix = "hpp"
source_suffix = "cpp"
name_str = "name"
file_prefix_str = "file_prefix"
interface_prefix_str = "interface_prefix"
description_str = "description"
has_help_str = "has_help"
file_encoding = "utf-8"

# A valid implementation section has an entry "file_prefix = "
def is_impl_section_valid(section):
    return (file_prefix_str in section)

# A file and generator header for each file
def write_file_header(stream, file_suffix):
    stream.write(
        f"""/*!
 * @file {module_file_prefix}.{file_suffix}
 *
 * Generated by {os.path.basename(__file__)}
 */
"""
        )

# Write all of the header file between the include guards
def write_header_file(header, module_section):
    guard_macro = (module_section[file_prefix_str]+"_"+header_suffix).upper()
    class_name = module_section[name_str]
    header.write(
        f"""
#ifndef {guard_macro}
#define {guard_macro}

#include "include/ConfiguredModule.hpp"
#include "include/Module.hpp"

#include "{module_section[interface_prefix_str]}{module_section[file_prefix_str]}.{header_suffix}"

namespace Module {{

template <> Module<{class_name}>::map Module<{class_name}>::functionMap;
class {module_section[file_prefix_str]}Module : public Module<{class_name}> {{
    struct Constructor {{
        Constructor();
    }};
    static Constructor ctor;
}};

}} /* namespace Module */

#endif /* {guard_macro} */
"""
)

'''
Main program

Parse the module.cfg file in a directory and generate the corresponding
module source and header files.
'''
def main():
    config = configparser.ConfigParser()
    config.read(module_file_str)
    
    # Add in defaults, if optional data is absent
    if not interface_prefix_str in config[module_section_str]:
        config[module_section_str][interface_prefix_str] = ""
    
    # Error reporting if the module section is invalid
    if not name_str in config[module_section_str]:
        print(f"The main '{module_section_str}' section lacks a name for the module.")
        return 1
    
    if not file_prefix_str in config[module_section_str]:
        print(f"The main '{module_section_str}' section lacks a file prefix for the source files for the module.")
        return 2
    
    header = open(module_file_prefix + "." + header_suffix, "w", encoding=file_encoding)
    source = open(module_file_prefix + "." + source_suffix, "w", encoding=file_encoding)
    
    write_file_header(header, header_suffix)
    write_file_header(source, source_suffix)
    
    write_header_file(header, config[module_section_str])
    
    header.close()
    source.close()
    
if __name__ == "__main__":
    main()
