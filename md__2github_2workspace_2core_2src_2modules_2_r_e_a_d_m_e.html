<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>netxsimdg: Modules</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">netxsimdg
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__2github_2workspace_2core_2src_2modules_2_r_e_a_d_m_e.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Modules</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a></p>
<p>The module system provides a way of selecting the configuration of NextSIM_DG at runtime, without having to re-compile the model to obtain different behaviour. It often operates along with the configuration system to allow selection of the particular implementation using the text config files. The module system provides a method of decoupling the selection of a particular implementation from its point of use.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Interfaces and implementations</h1>
<p>The module system works with classes defined using typical C++ polymorphic classes. An abstract interface class defines the visible behaviour of the module and one or more implementation classes derived from it. No further code is required in the interface or implementation classes to use the module system. However, and addition Module class is required to provide the necessary infrastructure.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
<code>Module</code> namespace and class</h1>
<p>The Module infrastructure provides a pair of templated functions <code>getInstance&lt;T&gt;()</code> and <code>getImplementation&lt;T&gt;()</code> in the <code>Module</code> namespace. By calling specializations of these functions, an instance of the the define implementation class can be obtained. For a new instance <code>getInstance&lt;T&gt;()</code> is called which returns a <code>std::unique_ptr</code> of type of the interface class, pointing at a new instance of the implementation class. The <code>getImplementation&lt;T&gt;()</code> function returns a reference to a static instance of the implementation class, which can be used when a new instance is not needed. This could be used for pseudo-static functions, for instance.</p>
<p>The implementation is set using the <code>setImplementation&lt;T&gt;()</code> function, which takes a string argument of the name of the implementaion to be used, allowing the implementation to be set from the text of a configuration file.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Implementing a new <code>IInterfaceModule</code> class</h1>
<p>In the following description, the interface class is named <code>IInterface</code> and the implementation class is <code>Implmentation</code>.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
The header</h2>
<p>The header contains the declaration of the Module specialization for <code>IInterface</code>. It will contain an include of the <code>Module</code> header and of the <code>IInterface</code> header. Within the <code>Module</code> namespace there is the explicit specialization of the <code>functionMap</code> variable. </p><div class="fragment"><div class="line">template &lt;&gt; Module&lt;IInterface&gt;::map Module&lt;IInterface&gt;::functionMap;</div>
</div><!-- fragment --><p>There is also the declaration of the Module class itself. This consists mostly of boilerplate code to set up the module class. </p><div class="fragment"><div class="line">class IInterfaceModule : public Module&lt;IInterface&gt; {</div>
<div class="line">    struct Constructor {</div>
<div class="line">        Constructor();</div>
<div class="line">    };</div>
<div class="line">    static Constructor ctor;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md5"></a>
The source</h2>
<p>The source file for the Module class consists of template specializations to relate the names of the implementations to the classes themselves. The code for the source file can be generated using the Python 3 script <code><a class="el" href="module__maker_8py_source.html">module_maker.py</a></code>. This takes an <code>--interface</code> argument for the interface class name and then a list of the implementation classes. The first implementation in the list is used as the default which will be returned if no other implementation is selected. The text of the source file is then returned to standard output.</p>
<p>To implement the source of the module without using the python script, it is best to base it off one of the existing source files.</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Using the module</h1>
<h2><a class="anchor" id="autotoc_md7"></a>
Selecting an implementation</h2>
<p>When the module is constructed a default implmentation is loaded and will be returned if no other implementation is selected. Otherwise, one of the other implementations will be selected when named as an argument to <code>setImplementation()</code>. If the argument to <code>setImplementation()</code> is not the name of an implementation of the interface then a <code>std::out_of_range</code> exception will be throw, based on the underlying <code>std::map</code>.</p>
<p>How the implementation selecting string is selected is entirely up to the developer. The <code>boost::program_options</code> based classes <code>Configurator</code> and <code>ConfiguredModule</code> may be of use.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Using the interface</h2>
<p>The usual way of using a module is to either acquire a fresh instance using <code>getInstance()</code> or by using the static instance that can be referenced through <code>getImplementation()</code>. The instance returned by <code>getInstance()</code> is referred to by the <code>std::unique_ptr</code> that is returned, which removes the need for disposing of it when its use is complete.</p>
<p>Either through the reference or the smart pointer, the implementation can be accessed using any of the functions defined in the interface class, just as with any other C++ polymorphic class. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
